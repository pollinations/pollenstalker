{"version":3,"sources":["network/ipfsWebClient.js","network/ipfsState.js","utils/logProgressToConsole.js","network/ipfsConnector.js","network/utils.js","styles.js","network/ipfsPubSub.js","hooks/IPFS hooks/useIPFS.js","utils/media2display.js","utils/notebookMetadata.js","components/atoms/AnimatedImage.js","components/molecules/Card.js","components/molecules/InfoCard.js","pages/home.js","utils/convenience.js","hooks/IPFS hooks/useSubscribe.js","App.js","index.js"],"names":["debug","Debug","fetchAndMakeURL","a","name","cid","text","ext","extname","doImport","shouldImport","webURL","getWebURL","textContent","parse","IPFSWebState","contentID","skipCache","getIPFSState","length","toLowerCase","callback","f","reader","ipfsReader","cachedIPFSState","type","path","rootCID","console","log","cache","processFile","rest","key","toString","_getIPFSState","ls","get","stringCID","_debug","extend","files","filenames","map","promises","file","join","Promise","all","contents","contentResult","Object","fromEntries","zip","defineProperty","value","dataFetchers","fileResult","json","buffer","s","IPFS_HOST","_client","AUTH","Buffer","from","getClient","getIPFSDaemonURL","then","url","create","port","timeout","client","ipfsLsCID","options","ipfsGet","mfsRoot","Date","toISOString","replace","writer","initialRootCID","initializedFolder","initializeMFSFolder","returnRootCID","func","tmpPath","args","getCID","methods","add","ipfsAdd","addFile","ipfsAddFile","rm","ipfsRm","mkDir","ipfsMkdir","noop","close","pin","ipfsPin","getRootCID","rootCid","ipfsCp","localIPFSAvailable","ipfsPath","cp","recursive","filename","split","firstLine","cidString","Error","stripSlashIPFS","CID","asCID","_normalizeIPFS","optionallyResolveIPNS","toPromise","result","filter","undefined","content","message","onlyLink","cat","chunkArrays","chunks","contentArray","concat","localPath","basename","dirname","createReadStream","startsWith","ipfsResolve","mkdir","parents","stat","force","last","resolve","nocache","asyncGen","error","retryException","n","awaitSleep","NAV_BORDER_BOTTOM","Container","styled","div","Main","button","body","subscribeCID","nodeID","suffix","heartbeatDeadCallback","heartbeatChecker","gotHeartbeat","closeHeartbeat","unsubscribe","aborted","handleMessage","subscribeCallback","heartbeatStateCallback","lastHeartbeat","getTime","heartbeatTimeout","setHeartbeatTimeout","setTimeout","timeSinceLastHeartbeat","alive","HEARTBEAT_FREQUENCY","time","clearTimeout","topic","abort","AbortController","onError","errorArgs","signal","doSub","handler","data","TextDecoder","decode","pubsub","subscribe","res","useIPFS","useState","ipfs","setIpfsState","useEffect","_mediaTypeMap","getMedia","output","extensions","filterByExtensions","any","identity","endsWith","keys","reverse","mediaToDisplay","mediaIn","EMPTY_MEDIA","firstImage","shift","images","array","nth","Math","max","floor","e","i","every_nth","first","extractParametersWithComment","codeRows","params","extractParameters","extractEnumerableParameters","previousRow","trim","includes","description","slice","match","defaultVal","enumString","enumOptions","mapToJSONFormField","enum","default","title","isParameterCell","cell","isMarkdownCell","getNotebookMetadata","metadata","notebookJSON","cells","descriptionCell","find","parameterCell","parameterTexts","allParameters","param","properties","primaryInput","form","numCells","readMetadata","input","primaryInputField","firstContent","ImgAnimated","imgs","isHover","count","setCount","interval","setInterval","state","clearInterval","style","width","minHeight","backgroundColor","display","alignItems","src","height","PollenCard","props","setHover","className","onMouseOver","onMouseOut","children","InfoCard","pollenList","lastDate","elapsed","toFixed","moment","diff","Home","xs","setCid","useSubscribe","setList","setLastDate","prompt","padding","entries","pollen","reduce","r","v","k","push","App","initialDate","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.1247f0bc.chunk.js","sourcesContent":["\nimport Debug from \"debug\";\nimport { parse } from \"json5\";\nimport { extname } from \"path\";\nimport { getWebURL, writer } from \"./ipfsConnector.js\";\nimport { getIPFSState } from \"./ipfsState.js\";\n\nconst debug = Debug(\"ipfsWebClient\")\n\n// fetch json and texts files. convert media and other files to URLs pointing to the IPFS gateway\nconst fetchAndMakeURL = async ({ name, cid, text }) => {\n\n    const ext = extname(name);\n    const doImport = shouldImport(ext);\n    debug(\"ext\", ext, \"extIsJSON\", doImport);\n    const webURL = getWebURL(cid, name);\n    if (doImport) {\n        const textContent = await text();\n\n        try {\n            return parse(textContent);\n        } catch (_e) {\n            debug(\"result was not json. returning raw.\")\n            return textContent;\n        }\n\n    } else {\n        return webURL;\n    }\n}\n\n// Return IPFS state. Converts all JSON/text content to objects and binary cids to URLs.\nexport const IPFSWebState = (contentID, skipCache = false) => {\n    debug(\"Getting state for CID\", contentID)\n    return getIPFSState(contentID, fetchAndMakeURL, skipCache);\n}\n\nexport const getWriter = ipfs => {\n    debug(\"getting input writer for cid\", ipfs[\".cid\"]);\n    const w = writer(ipfs[\".cid\"]);\n\n    // try to close the writer when window is closed\n    const previousUnload = window.onbeforeunload;\n    window.onbeforeunload = () => {\n        previousUnload && previousUnload();\n        w.close();\n        return undefined;\n    };\n\n    return w;\n}\n\n// Update /input of ipfs state with new inputs (from form probably)\nexport const updateInput = async (inputWriter, inputs) => {\n\n    debug(\"updateInput\", inputs);\n    debug(\"removing output\")\n    await inputWriter.rm(\"output\")\n    debug(\"Triggered dispatch. Inputs:\", inputs, \"cid before\", await inputWriter.cid())\n\n    // this is a bit hacky due to some wacky file naming we are doing\n    // will clean this up later\n    const writtenFiles = []\n\n    for (let [key, val] of Object.entries(inputs)) {\n        // check if value is a string and base64 encoded file and convert it to a separate file input\n        if (typeof val === \"string\" && val.startsWith(\"data:\")) {\n\n            // Parse file details from data url\n            debug(\"Found base64 encoded file\", key);\n            // const mimeType = val.split(\";\")[0].split(\":\")[1];\n            const filename = val.split(\";\")[1].split(\"=\")[1]\n            const fileContent = val.split(\",\")[1]\n\n            // convert fileContent to buffer\n            const buffer = Buffer.from(fileContent, \"base64\")\n            const path = \"input/\" + filename\n\n            debug(\"Writing file\", filename)\n            await inputWriter.add(path, buffer)\n\n            // We should not need to reference the absolute path here.\n            // Will fix on the pollinator side later\n            val = `/content/ipfs/input/${filename}`\n            writtenFiles.push(path)\n        }\n\n        const path = \"input/\" + key\n        if (!writtenFiles.includes(path))\n            await inputWriter.add(path, JSON.stringify(val))\n    }\n\n    return await inputWriter.cid()\n}\n\n// only download json files, notebooks and files without extension (such as logs, text, etc)\nfunction shouldImport(ext) {\n    return ext.length === 0 || ext.toLowerCase() === \".json\" || ext.toLowerCase() === \".ipynb\" || ext.toLowerCase() === \".md\";\n}\n\n","\n\nimport  { stringCID, reader } from \"./ipfsConnector.js\";\nimport Debug from \"debug\";\nimport { zip } from \"ramda\";\n\nimport { extname, join } from \"path\";\nimport {PromiseAllProgress} from \"../utils/logProgressToConsole.js\";\nimport { parse } from \"json5\";\n\nconst debug = Debug(\"ipfsState\");\n\n\n// Recursively get the IPFS content and transform it into a JS object.\n// The callback is called for each file in the directories which can fetch or process them further\nexport const getIPFSState = async (contentID, callback=f=>f, skipCache=false) => {\n    \n    const ipfsReader = await reader();\n    debug(\"Getting state for CID\", contentID);\n    try {\n    return await cachedIPFSState(ipfsReader, { cid: contentID, name: \"root\", type: \"dir\", path: \"/\", rootCID: contentID}, callback, skipCache);\n    } catch (e) { console.log(e)}\n\n}\n\n\n// Caching\n\nconst cache = {};\nconst cachedIPFSState = (ipfsReader, {cid, ...rest}, processFile, skipCache ) => {\n    const key = `${cid} - ${processFile.toString()}`;\n    if (!cache[key] || skipCache) {\n        debug(\"cache miss\",cid);\n        cache[key] = _getIPFSState(ipfsReader, {cid, ...rest}, processFile, skipCache);\n    } else\n        debug(\"cache hit\",cid);\n    return cache[key];\n}\n\n// Do the actual work\nconst _getIPFSState = async (ipfsReader, { cid, type, name, path, rootCID }, processFile, skipCache) => {\n    debug(\"ipfs state getter callback name\",processFile.toString())\n    const {ls, get} = ipfsReader;\n    cid = stringCID(cid);\n    const _debug = debug.extend(`_getIPFSState(${path})`);\n    _debug(\"Getting state for\", type, name, cid);\n    if (type === \"dir\") {\n        const files = await ls(cid);\n        _debug(\"Got files for\", name, cid, files);\n        const filenames = files.map(({ name }) => name);\n        const contents = await PromiseAllProgress(path, files.map(\n            file => cachedIPFSState(ipfsReader, {...file, path:join(path,file.name), rootCID}, processFile, skipCache)\n            ));\n\n        const contentResult = Object.fromEntries(zip(filenames, contents));\n        _debug(\"contents\",contentResult);\n        // Add non-enumerable property .cid to each \"folder\" in object\n        Object.defineProperty(contentResult, \".cid\", { value: cid });\n        return contentResult;\n    }\n     \n\n    if (type === \"file\") {\n        const fileResult = await processFile({ \n            cid, \n            path, \n            name, \n            rootCID, \n            ...dataFetchers(cid, ipfsReader)\n        }, ipfsReader);\n        //_debug(\"got result of processFile length\", fileResult?.length);\n        return fileResult;\n    }\n\n    throw `Unknown file type \"${type}\" encountered. Path: \"${path}\", CID: \"${cid}\".`;\n};\n\n// Provide functions similar to http response for getting contents of a file on IPFS\nconst dataFetchers = (cid,{get}) => {\n    debug(\"creating data fetchers for cid\",cid);\n    return{\n      json: async () => parse((await get(cid)).toString()),\n      text: async () => (await get(cid)).toString(),\n      buffer: async () => await get(cid)\n    };\n};\n","// import {MultiBar, Presets, SingleBar} from 'cli-progress';\n\n// import { noop } from \"../network/utils\";\n\n// const multibar = new MultiBar({\n//     clearOnComplete: false,\n//     hideCursor: false,\n//     format: ' {bar} | \"{cid}\" | {value}/{total}',\n//     // barCompleteChar: '\\u2588',\n//     // barIncompleteChar: '\\u2591',\n//     stopOnComplete: false,\n//     fps:8\n// });\n\n// const logProgress = (total, name=\"\") => { \n    \n//     const bar = multibar.create(total, 0, {name});\n\n//     const update = increment => {\n//         bar.increment(increment);\n//     }\n\n//     const remove = () => {\n//         // bar.stop();\n//         multibar.remove(bar);\n//     }\n\n//     return [update, remove];\n// } \n\n// export default logProgress;\n\n// export const logProgressAsync = async function* (iterator, total, name)  {\n//     const [log, remove] = logProgress(total,name);\n//     for await (const chunk of iterator) {\n//         log(chunk.length,name);\n//         yield(chunk);\n//     }\n//     remove();\n// }\n\n// import { MultiProgressBars } from 'multi-progress-bars';\n\n// import pProgress from \"p-progress\";\n// const mpb = new MultiProgressBars({stream:process.stderr, anchor:\"bottom\"});\n\nexport default () => null;\n\nexport const logProgressAsync = it => it;\n\nlet globalBarIndex = 0;\n\nexport const PromiseAllProgress = (name, promises) => Promise.all(promises);\n// {\n//     const promiseProgress = pProgress.all(promises);\n//     globalBarIndex++;\n//     const barIndex = globalBarIndex;\n//     mpb.addTask(name, {type:\"percentage\",index: barIndex});\n//     promiseProgress.onProgress(p => {\n//         // console.log(p)\n//         mpb.updateTask(name, p);\n//         if (p >= 1) {\n//             mpb.done(name);\n//             globalBarIndex--;\n//         }\n//     })\n//     return promiseProgress;\n// };\n\n","\nimport Debug from \"debug\";\nimport { createReadStream } from \"fs\";\nimport { create } from \"ipfs-http-client\";\nimport all from \"it-all\";\nimport { CID } from \"multiformats/cid\";\nimport { basename, dirname, join } from \"path\";\nimport { last } from \"ramda\";\nimport { AUTH, noop, toPromise } from \"./utils.js\";\n\n\n\n\nconst debug = Debug(\"ipfsConnector\")\n\nconst IPFS_HOST = \"https://api.pollinations.ai\";\n\nlet _client = null;\n\nconst base64Decode = s => Buffer.from(s, \"base64\").toString(\"utf8\");\n\nconst Authorization = base64Decode(AUTH);\n\n// create a new IPFS session\nexport async function getClient() {\n    if (!_client) {\n        _client = getIPFSDaemonURL().then(url => create({\n            port: 5005,\n            url, timeout: \"2h\",\n        }))\n    }\n    return _client;\n}\n\n\n// basic IPFS read access\nexport async function reader() {\n    const client = await getClient();\n    return {\n        ls: async cid => await ipfsLsCID(client, cid),\n        get: async (cid, options = {}) => await ipfsGet(client, cid, options)\n    }\n}\n\n// randomly assign a temporary folder in the IPFS mutable filesystem\n// in the future ideally we'd be running nodes in the browser and on colab and could work in the root\nconst mfsRoot = `/tmp_${(new Date()).toISOString().replace(/[\\W_]+/g, \"_\")}`;\n\n\n// Create a writer to modify the IPFS state\n// It creates a temporary folder in the IPFS mutable filesystem \n// so calling close is important\nexport function writer(initialRootCID = null) {\n\n\n    // Promise to a temporary folder in the IPFS mutable filesystem\n    let initializedFolder = getClient().then(client => initializeMFSFolder(client, initialRootCID))\n\n    // calls the function with client and absolute path and finally return the root CID\n    const returnRootCID = func => async (path = \"/\", ...args) => {\n\n        const client = await getClient()\n\n        await initializedFolder\n        debug(\"join\", mfsRoot, path)\n        const tmpPath = join(mfsRoot, path)\n\n        // execute function\n        await func(client, tmpPath, ...args)\n\n        // return the root CID\n        return await getCID(client, mfsRoot)\n    };\n\n    const methods = {\n        add: returnRootCID(ipfsAdd),\n        addFile: returnRootCID(ipfsAddFile),\n        rm: returnRootCID(ipfsRm),\n        mkDir: returnRootCID(ipfsMkdir),\n        cid: returnRootCID(noop),\n        close: async () => {\n            debug(\"closing input writer. Deleting\", mfsRoot)\n            await initializedFolder\n            await ipfsRm(await getClient(), mfsRoot)\n        },\n        pin: async cid => await ipfsPin(await getClient(), cid)\n    }\n\n    // const methodsWithRetry = mapObjIndexed(retryException, methods)\n\n    return methods; //WithRetry\n}\n\n\n// Initializes a folder in `mfsRoot` with the given CID\nasync function initializeMFSFolder(client, initialRootCID) {\n\n    const getRootCID = async () => await getCID(client, mfsRoot);\n\n    let rootCid = await getRootCID();\n    debug(\"existing root CID\", rootCid);\n\n    if (rootCid === null) {\n        if (initialRootCID === null) {\n            debug(\"Creating mfs root since it did not exist.\");\n            await ipfsMkdir(client, mfsRoot);\n        } else {\n            debug(\"Copying supplied rootCID\", initialRootCID, \"to MFS root.\");\n            await ipfsCp(client, initialRootCID, mfsRoot);\n        }\n        rootCid = await getRootCID();\n        debug(\"new root CID\", rootCid);\n    } else {\n        debug(\"Checking if supplied cid is the same as root cid\");\n        if (rootCid !== initialRootCID) {\n            debug(\"CIDs are different. Removing existing  MFS root\");\n            await ipfsRm(client, mfsRoot);\n            debug(\"Copying\", rootCid, \"to mfs root.\");\n            await ipfsCp(client, rootCid, mfsRoot);\n        }\n    }\n    return await getRootCID();\n}\n\n\nconst localIPFSAvailable = async () => {\n    return false;\n}\n\nconst getIPFSDaemonURL = async () => {\n    if (await localIPFSAvailable()) {\n        debug(\"Ipfs at localhost:5001 is reachable. Connecting...\");\n        return \"http://localhost:5001\";\n    }\n    debug(\"localhost:5001 is not reachable. Connecting to\", IPFS_HOST);\n    return IPFS_HOST;\n}\n\n\nconst ipfsCp = async (client, cid, ipfsPath) => {\n    debug(\"Copying from \", `/ipfs/${cid}`, \"to\", ipfsPath);\n    return await client.files.cp(`/ipfs/${cid}`, ipfsPath);\n}\n\nconst ipfsPin = async (client, cid) => {\n    debug(\"Pinning\", cid);\n    return await client.pin.add(cid, { recursive: true });\n}\n\nexport const getWebURL = (cid, name = null) => {\n    const filename = name ? `?filename=${name}` : '';\n    return `https://ipfs.pollinations.ai/ipfs/${cid}${filename}`\n};\n\nexport const getIPNSURL = (id) => {\n    return `https://ipfs.pollinations.ai/ipns/${id}`;\n};\n\nconst stripSlashIPFS = cidString => {\n    if (!cidString)\n        throw new Error(\"CID is falsy\");\n    return cidString.replace(\"/ipfs/\", \"\")\n};\n\nconst firstLine = s => s.split(\"\\n\")[0];\n\nexport const stringCID = file => firstLine(stripSlashIPFS(file instanceof Object && \"cid\" in file ? file.cid.toString() : (CID.asCID(file) ? file.toString() : (file instanceof Buffer ? file.toString() : file))));\n\nconst _normalizeIPFS = ({ name, path, cid, type }) => ({ name, path, cid: stringCID(cid), type });\n\nconst ipfsLsCID = async (client, cid) => {\n    try {\n        cid = await optionallyResolveIPNS(client, cid);\n        debug(\"calling ipfs ls with cid\", cid);\n        const result = (await toPromise(client.ls(stringCID(cid))))\n            .filter(({ type, name }) => type !== \"unknown\" && name !== undefined)\n            .map(_normalizeIPFS);\n        debug(\"got ipfs ls result\", result);\n        return result;\n    } catch (e) {\n        console.log(e)\n    }\n}\n\n\nconst ipfsAdd = async (client, path, content, options = {}) => {\n    debug(\"adding\", path, \"options\", options)\n    let cid = null\n    try {\n        // check if content has the async iterator symbol\n        // if (content[Symbol.asyncIterator]) {\n        //     debug(\"content is an async iterator\")\n        //     cid = stringCID(await toPromise1(client.addAll(content, options)))\n        // } else {\n        cid = stringCID(await client.add(content, options))\n        // }\n    } catch (e) {\n        debug(\"could not add file\", path, \"becaus of\", e.message, \". Maybe the content was deleted before it could be added?\")\n        return null\n    }\n\n    debug(\"added\", cid)\n\n\n    try {\n        debug(\"Trying to delete\", path)\n        await client.files.rm(path, { recursive: true })\n    } catch {\n        debug(\"Could not delete. Probably did not exist.\")\n    }\n    debug(\"copying to\", path)\n    try {\n        await client.files.cp(`/ipfs/${cid}`, path, { create: true })\n    } catch (e) {\n        debug(\"couldn't copy. file probably existed for some reason\")\n    }\n    return cid\n}\n\nconst ipfsGet = async (client, cid, { onlyLink = false }) => {\n\n    const _debug = debug.extend(`ipfsGet(${cid})`);\n\n    cid = await optionallyResolveIPNS(client, cid);\n\n    const chunkArrays = await all(client.cat(cid));\n\n    const chunks = chunkArrays.map(Buffer.from);\n\n    _debug(\"Got all chunks. Total:\", chunks.length);\n    if (chunks.length === 0)\n        return Buffer.from([]);\n\n    const contentArray = chunks.length > 1 ? Buffer.concat(chunks) : chunks[0];\n\n    // const contentArray = Buffer.concat(await toPromise(client.get(cid)));\n    _debug(\"Received content length:\", contentArray.length);\n    // debug(\"Content type\",contentArray)\n    return contentArray;\n};\n\nconst ipfsAddFile = async (client, ipfsPath, localPath) => {\n    debug(\"Adding file\", localPath, \"to\", ipfsPath);\n    // get filename from path\n    const filename = basename(localPath);\n    const folder = dirname(localPath);\n    await ipfsAdd(client, ipfsPath, createReadStream(localPath))\n}\n\nasync function optionallyResolveIPNS(client, cid) {\n    debug(\"Trying to resolve CID\", cid)\n    if (cid.startsWith(\"/ipns\"))\n        cid = await ipfsResolve(client, cid);\n    return cid;\n}\n\nasync function ipfsMkdir(client, path) {\n    debug(\"Creating folder\", path);\n    try {\n        await client.files.mkdir(path, { parents: true });\n    } catch (e) {\n        debug(\"couldn't create folder because it probably already exists\", e)\n    }\n    return await client.files.stat(path);\n}\n\nasync function ipfsRm(client, path) {\n    debug(\"Deleting\", path);\n    try {\n        await client.files.rm(path, { force: true, recursive: true });\n    } catch (e) {\n        debug(`couldn't delete \"${path}\"  because it probably doesn't exist`, e)\n    }\n}\n\nasync function getCID(client, path = \"/\") {\n    try {\n        return stringCID(await client.files.stat(path));\n    } catch (e) {\n        debug(\"Couldn't get CID for path\", path, \". Assuming it doesn't exist and returning null\");\n        return null;\n    }\n}\n\nconst ipfsResolve = async (client, path) =>\n    stringCID(last(await toPromise(client.name.resolve(path, { nocache: true }))));\n\n\n// test();","\nimport Debug from \"debug\";\nimport awaitSleep from \"await-sleep\";\nconst debug = Debug(\"utils\")\n\nexport const toPromise = async asyncGen => {\n    let contents = [];\n    try {\n        for await (const content of asyncGen) {\n            contents = [...contents, content];\n        }\n    } catch (e)Â {\n        console.error(\"Exception\", e);\n        return [undefined];\n    }\n    return contents;\n}\n\nexport const toPromise1 = async asyncGen => {\n    debug(\"getting values of asyncGen\");\n    for await (const value of asyncGen) {\n        debug(\"Got value\",value)\n        return value;\n    }\n    debug(\"No value found to convert to Promise\");\n    return null;\n}\n\nexport const noop = () => null;\n\nexport const zip = (arr, ...arrs) => {\n    return arr.map((val, i) => arrs.reduce((a, arr) => [...a, arr[i]], [val]));\n  }\n\nexport const curry = (fn, ...oldArgs) => (...newArgs) => {\n    const args = [...oldArgs, ...newArgs];\n    return (args.length < fn.length) ? curry(fn, ...args) : fn(...args);\n};\n\n\nconst shortenHash = (hash) => {\n    if (typeof hash !== 'string') return \"unknown hash type\";\n    return`${hash.slice(0,4)}...${hash.slice(-4)}`\n};\n\nexport const displayContentID = contentID => contentID ? shortenHash(contentID.toString()) : \"None\";\n\nexport const callLogger = (f,name = null) => (...args) => {\n    if (!name)\n      name = f.name;\n    const _debug = debug.extend(name);\n    _debug(\"--- Calling \",name, \"with input\", ...args);\n    _debug(\"--- In:\", ...args);\n    const output = f(...args);\n    if (output instanceof Promise)\n        output.then(out => _debug(\"--- Out:\", name,\":\", out));\n    else\n        _debug(\"--- Out:\", name,\":\", output);\n    return output;\n  }\n  \n  export const retryException = (f) => {\n    return async (...args) => {\n      let n = 5;\n      while (n-- > 0) {\n        try {\n            return await f(...args);\n        } catch (e) {\n            debug(`retryException #${n}`, e);\n            await awaitSleep(1000)\n        }\n      }\n      throw new Error(\"Too many retries\");\n    }\n}\n\n\n\nexport const AUTH = \"QmFzaWMgY0c5c2JHbHVZWFJwYjI1ekxXWnliMjUwWlc1a09sWnJSazVIYVdZM1kxUjBVWGt6\";\n\n","import styled from '@emotion/styled'\n\nconst NAV_HEIGHT = '3em'\nconst NAV_BORDER_BOTTOM = '0.01em'\n\nexport const Container = styled.div`\n  min-width: 500px;\n  max-width: 100vw;\n\n  min-height: calc( 100vh - ${NAV_HEIGHT} - ${NAV_BORDER_BOTTOM});\n  margin: 0;\n  padding: 0.3em;\n\n  display: grid;\n  grid-template-columns: repeat(\n    auto-fill,\n    minmax(300px, 1fr)\n  );\n  grid-template-rows: 1fr 2fr 1fr;\n    grid-gap: 1em;\n  grid-auto-flow: dense;\n\n  color: black;\n`\nexport const NavStyle = styled.div`\nwidth: 100%;\nheight: ${NAV_HEIGHT};\n\ndisplay: flex;\njustify-content: space-between;\nalign-items: center;\n\nh2 {\n  padding: 1.5em;\n}\nborder-bottom: ${NAV_BORDER_BOTTOM} solid rgba(127,127,127,0.5);\nbackground-color: rgba(0,0,0,0);\n`\n\nexport const ButtonStyle = styled.button`\nfont-style: italic;\ntext-decoration: underline;\ncolor: inherit;\nfont-size: 1em;\nborder: none;\ncursor: pointer;\npadding: 1.5em;\nbackground-color: transparent;\n`\n\nexport const Main = styled.body`\n\n\n  h2{\n      color: rgba(127,127,127);\n      font-weight: 400; \n  }\n  \n  h2,\n  a,\n  p {\n    color: black;\n  }\n  \n  a {\n    font-style: italic;\n    line-height: 1em;\n  }\n  \n  \n  .article {\n    height: 500px;\n    padding: 0em;\n    background: #fff;\n  \n    display: flex;\n    flex-direction: column;\n    justify-content: space-between;\n\n    \n    p {\n        padding: 0 1em;\n    }\n\n  }\n`","import awaitSleep from 'await-sleep';\nimport Debug from 'debug';\nimport { AbortController } from 'native-abort-controller';\nimport { Channel } from 'queueable';\nimport { getClient } from './ipfsConnector';\nimport { noop, retryException } from './utils';\n\n\nconst debug = Debug('ipfs:pubsub');\n\n\n// frequency at which to send heartbeats vis pubsub\nconst HEARTBEAT_FREQUENCY = 12;\n\n\n// create a publisher that sends periodic heartbeats as well as contentid updates\nexport function publisher(nodeID, suffix = \"/output\") {\n\n    debug(\"Creating publisher for\", nodeID, suffix);\n\n    let lastPublishCID = null;\n\n    const _publish = async cid => {\n        const client = await getClient()\n        await publish(client, nodeID, cid, suffix, nodeID)\n\n        // for some reason publishing twice in a row causes a socket error. sleep just in case\n        await awaitSleep(100)\n        lastPublishCID = cid;\n    };\n\n    // const interval = setInterval(() => {\n    //     if (lastPublishCID)\n    //         _publish(lastPublishCID);\n    // }, 5000);\n\n    const sendHeartbeat = async () => {\n        const client = await getClient();\n        publishHeartbeat(client, suffix, nodeID);\n    };\n\n    const handle = setInterval(sendHeartbeat, HEARTBEAT_FREQUENCY * 1000);\n\n    sendHeartbeat();\n\n    const close = () => {\n        debug(\"Closing publisher\", handle);\n        clearInterval(handle);\n        // clearInterval(interval);\n    };\n\n    return {\n        publish: _publish,\n        close\n    };\n}\n\nconst publishHeartbeat = async (client, suffix, nodeID) => {\n\n    if (nodeID === \"ipns\")\n        return;\n\n    try {\n        // debug(\"publishing heartbeat to\", nodeID, suffix);\n        await client.pubsub.publish(nodeID + suffix, \"HEARTBEAT\");\n    } catch (e) {\n        debug(\"Exception. Couldn't publish heartbeat. Ignoring...\", e.name)\n    }\n}\n\nasync function publish(client, nodeID, rootCID, suffix = \"/output\") {\n    const retryPublish = retryException(client.pubsub.publish)\n    debug(\"publish pubsub\", nodeID + suffix, rootCID);\n\n    try {\n        if (nodeID === \"ipns\")\n            await experimentalIPNSPublish(client, rootCID);\n        else\n            await retryPublish(nodeID + suffix, rootCID)\n    } catch (e) {\n        debug(\"Exception. Couldn't publish to\", nodeID, suffix, \"exception:\", e.name);\n    }\n}\n\n\nlet abortPublish = null;\n\nasync function experimentalIPNSPublish(client, rootCID) {\n    debug(\"publishing to ipns...\", rootCID);\n    if (abortPublish)\n        abortPublish.abort();\n    abortPublish = new AbortController();\n    await client.name.publish(rootCID, { signal: abortPublish.signal, allowOffline: true })\n        .then(() => {\n            debug(\"published...\", rootCID);\n            abortPublish = null;\n        })\n        .catch(e => {\n            debug(\"exception on publish.\", e);\n        });\n}\n\n// Generate an async iterable by subscribing to CIDs from a specific node id and suffix\nexport function subscribeGenerator(nodeID, suffix = \"/input\") {\n\n    const channel = new Channel();\n\n    debug(\"Subscribing to pubsub events from\", nodeID, suffix);\n\n    const unsubscribe = subscribeCID(nodeID, suffix,\n        cid => channel.push(cid)\n    );\n    return [channel, unsubscribe];\n}\n\n\n// Subscribe to a content ids from a nodeID and suffix. Callback is called with the content ids\n// Also receives and logs heartbeats received from the publisher\nexport function subscribeCID(nodeID, suffix = \"\", callback, heartbeatDeadCallback = noop) {\n\n    const { gotHeartbeat, closeHeartbeat } = heartbeatChecker(heartbeatDeadCallback);\n\n    let unsubscribe = null\n    let aborted = false\n    const handleMessage = message => {\n        if (message === \"HEARTBEAT\") {\n            gotHeartbeat();\n        } else {\n            callback(message);\n        }\n    }\n\n    (async () => {\n        while (!aborted) {\n            unsubscribe = subscribeCallback(nodeID + suffix, handleMessage)\n            // resubscribe every 5 minutes\n            await awaitSleep(5*60*1000)\n            unsubscribe()\n        }\n    })()\n\n    return () => {\n        debug(\"Unsubscribing from pubsub events from\", nodeID, suffix)\n        unsubscribe()\n        closeHeartbeat()\n        aborted = true\n    }\n};\n\n// if we don't receive a heartbeat from the publisher in 2 x HEARTBEAT_FREQUENCY seconds, \n// we assume the publisher is dead and call heartbeatDeadCallback\nfunction heartbeatChecker(heartbeatStateCallback) {\n\n    let lastHeartbeat = new Date().getTime();\n    let heartbeatTimeout = null;\n\n    function setHeartbeatTimeout() {\n        heartbeatTimeout = setTimeout(() => {\n            const timeSinceLastHeartbeat = (new Date().getTime() - lastHeartbeat) / 1000;\n            debug(\"Heartbeat timeout. Time since last:\", timeSinceLastHeartbeat);\n            heartbeatStateCallback({ lastHeartbeat, alive: false });\n        }, HEARTBEAT_FREQUENCY * 1.5 * 1000);\n        // debug(\"Set heartbeat timeout. Waiting \", HEARTBEAT_FREQUENCY * 1.5, \" seconds until next heartbeat\");\n    }\n\n    const gotHeartbeat = () => {\n        const time = new Date().getTime();\n        debug(\"Heartbeat from pubsub. Time since last:\", (time - lastHeartbeat) / 1000);\n        lastHeartbeat = time;\n        if (heartbeatTimeout)\n            clearTimeout(heartbeatTimeout);\n        heartbeatStateCallback({ alive: true });\n        setHeartbeatTimeout();\n    };\n\n    const closeHeartbeat = () => {\n        if (heartbeatTimeout)\n            clearTimeout(heartbeatTimeout);\n    };\n\n    setHeartbeatTimeout();\n\n    return { gotHeartbeat, closeHeartbeat }\n\n\n}\n\n\n// Subscribe to an ipfs topic with some rather ugly code to handle errors that probably don't even occur\nfunction subscribeCallback(topic, callback) {\n    let abort = new AbortController();\n\n    (async () => {\n\n        const onError = async (...errorArgs) => {\n            debug(\"onError\", ...errorArgs, \"aborting\")\n\n            if (abort.signal.aborted)\n                return;\n\n            abort.abort()\n            await awaitSleep(300)\n            debug(\"resubscribing\")\n            await doSub();\n        };\n\n        const handler = ({ data }) => {\n\n            if (abort.signal.aborted) {\n                console.error(\"Subscription to\", topic, \"was aborted. Shouldn't receive any more messages.\");\n            } else {\n                const message = new TextDecoder().decode(data)\n                callback(message);\n            }\n        }\n\n        const doSub = async () => {\n            const client = await getClient()\n            \n            try {\n                // abort.abort();\n                // abort = new AbortController()\n                console.log(\"Executing subscribe\", topic);\n                let res = await client.pubsub.subscribe(topic, (...args) => handler(...args), { onError, signal: abort.signal, timeout: \"4h\" });\n                console.log(res)\n            } catch (e) {\n                debug(\"subscribe error\", e, e.name);\n                if (e.name === \"DOMException\") {\n                    debug(\"subscription was aborted. returning\");\n                    return;\n                }\n\n                if (e.message?.startsWith(\"Already subscribed\"))\n                    return;\n                await awaitSleep(300);\n                await doSub();\n            }\n        };\n        doSub();\n    })();\n\n    return () => {\n        debug(\"subscribe abort was called\");\n        abort.abort();\n    };\n}\n\n\n// Skips repeated calls to the same function with the same arguments\nconst skipRepeatCalls = f => {\n    let lastValue = null;\n    return (value) => {\n        if (lastValue !== value) {\n            f(value);\n            lastValue = value;\n        };\n    }\n}","\nimport Debug from \"debug\";\nimport { useEffect, useState } from \"react\";\nimport { IPFSWebState } from \"../../network/ipfsWebClient\";\n\n\n\n\n\nconst debug = Debug(\"useIPFS\");\n\nconst useIPFS = (contentID, skipCache = false) => {\n    const [ipfs, setIpfsState] = useState({});\n\n    debug(\"ipfs state\", ipfs);\n\n    useEffect(() => {\n\n        debug(\"setContentID\", contentID);\n\n        if (contentID) {\n            debug(\"dispatching new contentID\", contentID);\n\n            IPFSWebState(contentID, skipCache)\n                .then(setIpfsState);\n        }\n    }, [contentID]);\n\n    return ipfs;\n};\n\n\n\nexport default useIPFS;\n\n\n","import Debug from \"debug\";\nimport { any, identity, last } from \"ramda\";\n\nconst debug = Debug(\"media\");\n\n// recognized media types\nconst _mediaTypeMap = {\n    \"all\": [\".jpg\", \".jpeg\", \".png\", \".mp4\",\".webm\"],\n    \"video\": [\".mp4\",\".webm\"],\n    \"image\": [\".jpg\", \".jpeg\", \".png\"],\n    \"text\": [\".md\", \".txt\"],\n    \"audio\": [\".mp3\", \".wav\", \".ogg\",\".flac\"],\n  }\n  \n// get first image for social media and other stuff    \nexport const getCoverImage = output => { \n  const image = output && getMedia(output, \"image\")[0];\n  debug(\"coverImage\", image);\n  return image ? [image[0], gzipProxy(image[1])] : null;\n}\n\n// get first video for social media and other stuff\nexport const getCoverVideo = output => output && getMedia(output, \"video\")[0];\n\n\n// Get all images and videos from ipfs output folder\nexport function getMedia(output, type=\"all\") {\n  \n  const extensions = _mediaTypeMap[type]\n\n  const filterByExtensions = filename => \n    any(identity, extensions.map(ext => filename.toLowerCase().endsWith(ext)))\n\n  if (!output) return []\n  \n  return Object.keys(output)\n  .filter(filterByExtensions)\n  .map(filename => [filename, output[filename]])\n  .reverse()\n}\n\nconst gzipProxy = path => {\n  const cid = last(path.split(\"/\"));\n  return `https://images.weserv.nl/?url=https://pollinations.ai/ipfs/${cid}`;\n}\n  \n\n\nexport function mediaToDisplay(output) {\n  const mediaIn = getMedia(output);\n  if (!mediaIn || mediaIn.length === 0) return EMPTY_MEDIA;\n\n  // remove first image for large display\n  const firstImage = mediaIn.shift()\n\n  const images = every_nth(mediaIn);\n\n  const first = {\n      filename: firstImage[0],\n      url: firstImage[1]\n  }\n\n  return { images, first }\n}\n\nfunction every_nth(array){\n  const nth = Math.max(1, Math.floor(array.length / 20))\n  return array.filter((e, i) => i % nth === nth - 1)\n}\n\nconst EMPTY_MEDIA = { images: [], first: {} }","import { parse } from \"json5\";\nimport { mediaToDisplay } from \"./media2display\";\n\n\n// extract parameters from the jupyter notebook's parameter cell\nfunction readMetadata(notebookJSON) {\n  if (!notebookJSON)\n    return null;\n\n  let { metadata, cells } = notebookJSON;\n\n  const { name } = metadata[\"colab\"]\n\n  const descriptionCell = cells.find(isMarkdownCell)\n  const parameterCell = cells.find(isParameterCell)\n\n  const description = descriptionCell ? descriptionCell[\"source\"]\n    .join(\"\\n\") : null;\n\n  const parameterTexts = parameterCell ? parameterCell[\"source\"] : null\n\n\n  if (!parameterTexts)\n    return null\n\n  const allParameters = parameterTexts\n    .map(extractParametersWithComment)\n    .filter(param => param)\n    .map(mapToJSONFormField)\n\n  const properties = Object.fromEntries(allParameters)\n  const primaryInput = allParameters[0][0]\n\n  return {\n    form: {\n      // \"title\": name,\n      // description,\n      // type, \n      properties\n    },\n    name,\n    description,\n    numCells: cells.length,\n    primaryInput\n  }\n\n};\n\n// Extract parameter with preceding comment (to override form description with something more meaningful)\nconst extractParametersWithComment = (text, i, codeRows) => {\n  const params = extractParameters(text) || extractEnumerableParameters(text);\n\n  const previousRow = codeRows[i - 1];\n  if (params && previousRow && previousRow.trim().startsWith(\"#\") && !previousRow.includes(\"#@param\")) {\n    const description = previousRow.trim().slice(1).trim();\n    return { ...params, description }\n  }\n\n  return params;\n}\n\n\n// Extracts the parameters from a Colab parameter row\nconst extractParameters = text => {\n  const match = text.match(/^([a-zA-Z0-9-_]+)\\s=\\s(.*)\\s+#@param\\s*{type:\\s*\"(.*)\"}/);\n  if (!match)\n    return null;\n  const [_text, name, defaultVal, type] = match;\n  return { name, defaultVal, type };\n}\n\n// Extracts the enumerable parameters from a Colab parameter row\nconst extractEnumerableParameters = text => {\n  const match = text.match(/^([a-zA-Z0-9-_]+)\\s=\\s*(.*)\\s*#@param\\s*(\\[.*\\])/)\n  if (!match)\n    return null\n  const [_text, name, defaultVal, enumString] = match\n  return { name, defaultVal, type: \"string\", enumOptions: parse(enumString) }\n}\n\nconst mapToJSONFormField = ({ name, defaultVal, type, description, enumOptions }) => {\n\n  // If the regex were better we would not need to trim here\n  defaultVal = defaultVal.trim()\n\n  if (defaultVal == \"True\" || defaultVal == \"False\")\n    defaultVal = defaultVal.toLowerCase()\n\n  return [name, {\n    enum: enumOptions, type, default: parse(defaultVal),\n    // title: description || name, \n    title: name,\n    description\n  }]\n}\n\n// finds the first cell that contains code and the string #@param\nconst isParameterCell = cell => cell[\"cell_type\"] === \"code\" && cell[\"source\"].join(\"\\n\").includes(\"#@param\");\n\n// finds the first cell of type markdown\nconst isMarkdownCell = cell => cell[\"cell_type\"] === \"markdown\";\n\n\nexport const getNotebookMetadata = ipfs => {\n\n  // Read metadata\n  const metadata = readMetadata((ipfs?.input && ipfs.input[\"notebook.ipynb\"]) || ipfs && ipfs[\"notebook.ipynb\"])  \n  \n  // get primary input type\n  const primaryInputField = metadata?.primaryInput\n\n  // Outputs\n  const primaryInput = ipfs?.input?.[primaryInputField]\n  const firstContent = mediaToDisplay(ipfs?.output)?.first\n\n  return { primaryInput, firstContent }\n}\n\n","import { useEffect, useState } from \"react\";\n\nconst ImgAnimated = ({imgs, isHover}) => {\nconst [ count, setCount ] = useState(0)\n\n// animate\n// a bit jittery maybe using a lib? idk\nuseEffect(()=>{\n    if (!isHover) return null\n    let interval = setInterval(() => {\n    setCount(state => (state + 1) % imgs.length)\n    }, 100);\n    return () => clearInterval(interval)\n},[isHover])\n\nreturn <div style={{width: '100%', minHeight: '50%',backgroundColor:'black',display: 'flex', alignItems: 'center'}}>\n    <img src={imgs[count]?.result?.url} style={{width: '100%', height: 'auto'}}/>\n</div>\n}\n\nexport default ImgAnimated","import { useState } from \"react\"\nimport ImgAnimated from \"../atoms/AnimatedImage\"\n\nconst PollenCard = props => {\n\n  const [isHover, setHover] = useState(false)\n\n  return <article \n    className='article' \n    onMouseOver={()=>setHover(true)} \n    onMouseOut={()=>setHover(false)}>\n    \n    <ImgAnimated imgs={props[1]} isHover={isHover}/>\n\n    <div>\n      <p children={props[0]}/>\n      <p children={`Frames: ${props[1].length}`}/>\n    </div>\n  </article>\n}\n\n  export default PollenCard","import moment from \"moment\"\n\nconst InfoCard = ({ pollenList, lastDate, elapsed }) => {\nreturn <>\n    <h2 children='follow the pollen'/>\n    <p children={`IMG count: ${pollenList.length}`}/>\n    <p children={`${(pollenList.length / lastDate).toFixed(2)} imgs / second`}/>\n    <p children={`${moment().diff(elapsed, 'minutes') } minutes elapsed`}/>\n</>\n}\n\nexport default InfoCard","import { useState, useEffect } from 'react'\nimport moment from 'moment'\nimport { groupBy } from '../utils/convenience'\n\n// IPFS stuff\nimport useSubscribe from '../hooks/IPFS hooks/useSubscribe'\nimport useIPFS from '../hooks/IPFS hooks/useIPFS'\nimport { getNotebookMetadata } from \"../utils/notebookMetadata\"\n\n// Cards\nimport PollenCard from '../components/molecules/Card'\nimport InfoCard from '../components/molecules/InfoCard'\n\n\nfunction Home({ elapsed }) {\n    const cid = useSubscribe(\"processing_pollen\")\n    const ipfs = useIPFS(cid)\n\n    const [ pollenList, setList ] = useState([])\n    const [ lastDate, setLastDate ] = useState()\n\n    useEffect(()=>{\n\n      // metadata\n      const { primaryInput, firstContent } = getNotebookMetadata(ipfs)\n      \n      // if empty return null\n      if (!firstContent.url) return null\n\n      // otherwise push item\n      setList(state => ([...state, { \n        prompt: primaryInput,\n        result: firstContent,\n        cid: ipfs.cid,\n      }]))\n\n      // time elapsed minutes\n      setLastDate( elapsed.diff(moment(), 'seconds') * -1)\n\n    },[ipfs])\n\n  \n  return  <>\n    <div style={{ padding: '1em' }}>\n      <InfoCard \n      pollenList={pollenList} \n      elapsed={elapsed} \n      lastDate={lastDate}/>\n    </div>\n    \n    {\n      Object.entries(groupBy(pollenList, pollen => pollen.prompt))\n      .map( pollen => <PollenCard key={pollen[0]} {...pollen}/>)\n    }\n  </>\n}\n\nexport default Home","// Accepts the array and key\nexport function groupBy(xs, f) {\n    return xs.reduce((r, v, i, a, k = f(v)) => ((r[k] || (r[k] = [])).push(v), r), {});\n}","import { useEffect, useState } from \"react\"\nimport { subscribeCID } from \"../../network/ipfsPubSub\"\n\n\nexport default (topic, suffix=\"\") => {\n    \n    const [cid, setCid] = useState(null)\n    useEffect(() => subscribeCID(topic, suffix, setCid), [topic, suffix])\n\n    return cid\n}","import { BrowserRouter } from \"react-router-dom\"\n\nimport { Router } from \"react-router\";\nimport { Route, Routes } from 'react-router'\nimport { ButtonStyle, Container, NavStyle } from './styles';\nimport moment from 'moment';\nimport Home from \"./pages/home\";\n\nconst getMinuteDifference = (start, end)=> parseInt(Math.abs(end.getTime() - start.getTime()) / (1000) % 60)\n\n\n\nconst App = () => {\n\nconst initialDate = moment()\n\n\nreturn <BrowserRouter>\n  {/* <Nav/> */}\n  <Container>\n      <Home elapsed={initialDate}/>\n  </Container>\n</BrowserRouter>\n}\n\n\n\n\n\nexport default App;","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport { Main } from './styles';\n\nReactDOM.render(\n  <React.StrictMode>\n    <Main>\n      <App />\n    </Main>\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}